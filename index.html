<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Checkers Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a3a, #0d1520);
            color: #f0f0f0;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: #ffcc00;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 20px;
        }
        
        .game-mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            background: linear-gradient(to bottom, #2a4a6e, #1a3a5a);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            min-width: 200px;
        }
        
        .mode-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .mode-btn.tutorial {
            background: linear-gradient(to bottom, #3a6e2a, #2a5a1a);
        }
        
        .mode-btn.computer {
            background: linear-gradient(to bottom, #4a2a6e, #3a1a5a);
        }
        
        .mode-btn.friend {
            background: linear-gradient(to bottom, #6e2a4a, #5a1a3a);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 700px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(30, 40, 60, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .player-info {
            text-align: center;
            padding: 10px 20px;
            border-radius: 8px;
            min-width: 150px;
        }
        
        .player-info.active {
            background: rgba(255, 204, 0, 0.2);
            border: 2px solid #ffcc00;
        }
        
        .player-name {
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .player-pieces {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .piece-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .player1-indicator {
            background: #ff3333;
            border: 1px solid #ff6666;
        }
        
        .player2-indicator {
            background: #3333ff;
            border: 1px solid #6666ff;
        }
        
        .king-indicator {
            background: radial-gradient(circle, #ffcc00, #ff9900);
            border: 1px solid #ffcc00;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 700px;
            aspect-ratio: 1 / 1;
            border: 10px solid #5a3921;
            border-radius: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
            margin-bottom: 30px;
        }
        
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .light-cell {
            background-color: #f0d9b5;
        }
        
        .dark-cell {
            background-color: #b58863;
        }
        
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            z-index: 10;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .piece:hover {
            transform: scale(1.05);
        }
        
        .piece.player1 {
            background: radial-gradient(circle at 30% 30%, #ff6666, #cc0000);
            border: 2px solid #ff3333;
        }
        
        .piece.player2 {
            background: radial-gradient(circle at 30% 30%, #6666ff, #0000cc);
            border: 2px solid #3333ff;
        }
        
        .piece.king::after {
            content: "♔";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffcc00;
            font-size: 1.5rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        .piece.selected {
            box-shadow: 0 0 0 3px #ffcc00, 0 0 15px #ffcc00;
        }
        
        .valid-move {
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(255, 255, 0, 0.6);
            border-radius: 50%;
            z-index: 5;
        }
        
        .capture-move {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px dashed rgba(255, 50, 50, 0.7);
            border-radius: 5px;
            z-index: 5;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 0.8; }
            100% { opacity: 0.4; }
        }
        
        .game-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            padding: 12px 24px;
            font-size: 1rem;
            background: linear-gradient(to bottom, #3a4a5e, #2a3a4e);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }
        
        .control-btn:hover {
            background: linear-gradient(to bottom, #4a5a6e, #3a4a5e);
            transform: translateY(-2px);
        }
        
        .control-btn.restart {
            background: linear-gradient(to bottom, #6e3a2a, #5a2a1a);
        }
        
        .control-btn.undo {
            background: linear-gradient(to bottom, #2a6e4a, #1a5a3a);
        }
        
        .game-status {
            margin-top: 20px;
            padding: 15px 30px;
            background: rgba(30, 40, 60, 0.8);
            border-radius: 10px;
            font-size: 1.3rem;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 700px;
        }
        
        .game-status.winner {
            background: rgba(40, 80, 40, 0.8);
            color: #aaffaa;
            font-weight: bold;
        }
        
        .tutorial-container {
            display: none;
            max-width: 900px;
            width: 100%;
            background: rgba(30, 40, 60, 0.9);
            border-radius: 15px;
            padding: 30px;
            margin-top: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .tutorial-container.active {
            display: block;
        }
        
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4a5a7a;
        }
        
        .tutorial-title {
            font-size: 2rem;
            color: #ffcc00;
        }
        
        .close-tutorial {
            background: #5a2a2a;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-content {
            line-height: 1.6;
        }
        
        .tutorial-section {
            margin-bottom: 25px;
        }
        
        .tutorial-section h3 {
            color: #66aaff;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        .tutorial-section p {
            margin-bottom: 10px;
        }
        
        .tutorial-list {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        .tutorial-list li {
            margin-bottom: 8px;
        }
        
        .rule-example {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(40, 50, 70, 0.7);
            border-radius: 8px;
        }
        
        .example-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 150px;
            height: 150px;
            border: 3px solid #5a3921;
            flex-shrink: 0;
        }
        
        .example-cell {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .example-piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
        }
        
        .example-text {
            flex-grow: 1;
        }
        
        .move-history {
            max-width: 700px;
            width: 100%;
            margin-top: 30px;
            background: rgba(30, 40, 60, 0.7);
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .move-history h3 {
            margin-bottom: 10px;
            color: #ffcc00;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }
        
        .move-item {
            padding: 5px 10px;
            background: rgba(50, 60, 80, 0.6);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        footer {
            margin-top: 40px;
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            padding: 20px;
            width: 100%;
            border-top: 1px solid #333;
        }
        
        @media (max-width: 768px) {
            .game-board {
                max-width: 95vw;
            }
            
            .game-header {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            .mode-btn {
                min-width: 160px;
                padding: 12px 20px;
                font-size: 1.1rem;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
        
        @media (max-width: 480px) {
            .game-mode-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .mode-btn {
                width: 90%;
            }
            
            .tutorial-container {
                padding: 20px 15px;
            }
            
            .rule-example {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .example-board {
                align-self: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Offline Checkers</h1>
            <p class="subtitle">A complete checkers game with tutorial, computer AI, and two-player mode</p>
            
            <div class="game-mode-selector">
                <button class="mode-btn tutorial" id="tutorialBtn">How to Play Checkers</button>
                <button class="mode-btn computer" id="playComputerBtn">Play vs Computer</button>
                <button class="mode-btn friend" id="playFriendBtn">Play with a Friend</button>
            </div>
        </header>
        
        <div class="game-container" id="gameContainer">
            <div class="game-header">
                <div class="player-info active" id="player1Info">
                    <div class="player-name">Player 1 (Red)</div>
                    <div class="player-pieces">
                        <div class="piece-indicator player1-indicator"></div>
                        <div class="piece-indicator player1-indicator"></div>
                        <div class="piece-indicator player1-indicator"></div>
                        <div class="piece-indicator king-indicator"></div>
                    </div>
                </div>
                
                <div class="player-info" id="player2Info">
                    <div class="player-name">Player 2 (Blue)</div>
                    <div class="player-pieces">
                        <div class="piece-indicator player2-indicator"></div>
                        <div class="piece-indicator player2-indicator"></div>
                        <div class="piece-indicator player2-indicator"></div>
                        <div class="piece-indicator king-indicator"></div>
                    </div>
                </div>
            </div>
            
            <div class="game-board" id="gameBoard">
                <!-- Board will be generated with JavaScript -->
            </div>
            
            <div class="game-status" id="gameStatus">
                Select a game mode to start playing!
            </div>
            
            <div class="game-controls">
                <button class="control-btn restart" id="restartBtn">Restart Game</button>
                <button class="control-btn undo" id="undoBtn">Undo Move</button>
                <button class="control-btn" id="hintBtn">Show Hint</button>
                <button class="control-btn" id="backToMenuBtn">Back to Menu</button>
            </div>
            
            <div class="move-history">
                <h3>Move History</h3>
                <div class="move-list" id="moveList">
                    <!-- Moves will be added here -->
                </div>
            </div>
        </div>
        
        <div class="tutorial-container" id="tutorialContainer">
            <div class="tutorial-header">
                <h2 class="tutorial-title">Checkers Rules & Tutorial</h2>
                <button class="close-tutorial" id="closeTutorialBtn">&times;</button>
            </div>
            
            <div class="tutorial-content">
                <div class="tutorial-section">
                    <h3>Objective</h3>
                    <p>The goal of checkers is to capture all of your opponent's pieces or block them so they cannot make any moves.</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>Basic Rules</h3>
                    <ul class="tutorial-list">
                        <li>Checkers is played on an 8x8 board with 64 squares, alternating between light and dark colors.</li>
                        <li>Each player starts with 12 pieces placed on the dark squares of the three rows closest to them.</li>
                        <li>Pieces can only move diagonally on dark squares.</li>
                        <li>Regular pieces (men) can only move forward diagonally.</li>
                        <li>If a piece reaches the opposite end of the board, it becomes a King and can move both forward and backward.</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h3>Moving Pieces</h3>
                    <div class="rule-example">
                        <div class="example-board" id="moveExampleBoard">
                            <!-- Example board for move demonstration -->
                        </div>
                        <div class="example-text">
                            <p><strong>Regular Moves:</strong> Click on your piece to select it, then click on an empty dark square diagonally in front of it to move.</p>
                            <p>Valid moves will be highlighted with yellow dots.</p>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3>Capturing Pieces</h3>
                    <div class="rule-example">
                        <div class="example-board" id="captureExampleBoard">
                            <!-- Example board for capture demonstration -->
                        </div>
                        <div class="example-text">
                            <p><strong>Jumps:</strong> If your opponent's piece is diagonally adjacent to your piece and the square beyond it is empty, you must jump over and capture it.</p>
                            <p>Multiple jumps in one turn are allowed if they're available.</p>
                            <p>Capturing moves are highlighted with a red dashed border.</p>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3>King Pieces</h3>
                    <div class="rule-example">
                        <div class="example-board" id="kingExampleBoard">
                            <!-- Example board for king demonstration -->
                        </div>
                        <div class="example-text">
                            <p><strong>Kings:</strong> When a piece reaches the opposite end of the board, it becomes a King (crowned with a ♔ symbol).</p>
                            <p>Kings can move and jump both forward and backward diagonally.</p>
                            <p>Kings are more powerful and can capture in multiple directions.</p>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3>Game Modes</h3>
                    <ul class="tutorial-list">
                        <li><strong>Play vs Computer:</strong> Play against an AI opponent with adjustable difficulty.</li>
                        <li><strong>Play with a Friend:</strong> Two players take turns on the same device.</li>
                        <li><strong>How to Play:</strong> This tutorial you're reading right now!</li>
                    </ul>
                    <p>Select a game mode from the buttons above to start playing!</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Offline Checkers Game | Made with HTML, CSS & JavaScript | Works completely offline</p>
        </footer>
    </div>

    <script>
        // Game state
        let gameState = {
            board: [],
            currentPlayer: 1,
            selectedPiece: null,
            validMoves: [],
            gameMode: null, // 'computer' or 'friend'
            gameActive: false,
            moveHistory: [],
            player1Pieces: 12,
            player2Pieces: 12,
            player1Kings: 0,
            player2Kings: 0,
            lastMove: null,
            computerDifficulty: 'medium'
        };

        // DOM elements
        const gameBoard = document.getElementById('gameBoard');
        const gameStatus = document.getElementById('gameStatus');
        const player1Info = document.getElementById('player1Info');
        const player2Info = document.getElementById('player2Info');
        const tutorialContainer = document.getElementById('tutorialContainer');
        const moveList = document.getElementById('moveList');

        // Buttons
        const tutorialBtn = document.getElementById('tutorialBtn');
        const playComputerBtn = document.getElementById('playComputerBtn');
        const playFriendBtn = document.getElementById('playFriendBtn');
        const closeTutorialBtn = document.getElementById('closeTutorialBtn');
        const restartBtn = document.getElementById('restartBtn');
        const undoBtn = document.getElementById('undoBtn');
        const hintBtn = document.getElementById('hintBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');

        // Initialize example boards for tutorial
        function initExampleBoards() {
            // Move example board
            const moveExampleBoard = document.getElementById('moveExampleBoard');
            createExampleBoard(moveExampleBoard, 'move');
            
            // Capture example board
            const captureExampleBoard = document.getElementById('captureExampleBoard');
            createExampleBoard(captureExampleBoard, 'capture');
            
            // King example board
            const kingExampleBoard = document.getElementById('kingExampleBoard');
            createExampleBoard(kingExampleBoard, 'king');
        }

        // Create example board for tutorial
        function createExampleBoard(container, type) {
            container.innerHTML = '';
            
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'example-cell';
                    cell.style.backgroundColor = (row + col) % 2 === 0 ? '#f0d9b5' : '#b58863';
                    
                    // Add pieces based on example type
                    if (type === 'move') {
                        if (row === 1 && col === 1) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player1';
                            cell.appendChild(piece);
                        }
                        if (row === 2 && col === 0) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player2';
                            cell.appendChild(piece);
                        }
                    } else if (type === 'capture') {
                        if (row === 1 && col === 1) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player1';
                            cell.appendChild(piece);
                        }
                        if (row === 2 && col === 2) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player2';
                            cell.appendChild(piece);
                        }
                    } else if (type === 'king') {
                        if (row === 0 && col === 1) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player1 king';
                            cell.appendChild(piece);
                        }
                        if (row === 3 && col === 2) {
                            const piece = document.createElement('div');
                            piece.className = 'example-piece player2';
                            cell.appendChild(piece);
                        }
                    }
                    
                    container.appendChild(cell);
                }
            }
        }

        // Initialize the game board
        function initBoard() {
            gameBoard.innerHTML = '';
            gameState.board = [];
            
            // Create 8x8 board
            for (let row = 0; row < 8; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 8; col++) {
                    // Create cell
                    const cell = document.createElement('div');
                    cell.className = `cell ${(row + col) % 2 === 0 ? 'light-cell' : 'dark-cell'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Add pieces for starting positions
                    if ((row + col) % 2 === 1) {
                        if (row < 3) {
                            // Player 2 pieces (top rows)
                            gameState.board[row][col] = { player: 2, isKing: false };
                            const piece = createPieceElement(2, false);
                            cell.appendChild(piece);
                        } else if (row > 4) {
                            // Player 1 pieces (bottom rows)
                            gameState.board[row][col] = { player: 1, isKing: false };
                            const piece = createPieceElement(1, false);
                            cell.appendChild(piece);
                        } else {
                            gameState.board[row][col] = null;
                        }
                    } else {
                        gameState.board[row][col] = null;
                    }
                    
                    // Add click event to cell
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    
                    gameBoard.appendChild(cell);
                }
            }
            
            updatePlayerInfo();
            updateGameStatus("Player 1's turn (Red)");
            moveList.innerHTML = '<div class="move-item">Game started</div>';
        }

        // Create a piece element
        function createPieceElement(player, isKing) {
            const piece = document.createElement('div');
            piece.className = `piece player${player}`;
            if (isKing) piece.classList.add('king');
            piece.dataset.player = player;
            piece.dataset.king = isKing;
            return piece;
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameState.gameActive) return;
            
            // If it's computer's turn and we're playing against computer, ignore clicks
            if (gameState.gameMode === 'computer' && gameState.currentPlayer === 2) {
                return;
            }
            
            const cell = gameState.board[row][col];
            
            // If clicking on a piece
            if (cell && cell.player === gameState.currentPlayer) {
                selectPiece(row, col);
            } 
            // If clicking on a valid move cell
            else if (gameState.selectedPiece && isValidMoveTarget(row, col)) {
                makeMove(row, col);
            }
        }

        // Select a piece
        function selectPiece(row, col) {
            // Clear previous selection
            clearSelection();
            
            // Set selected piece
            gameState.selectedPiece = { row, col };
            
            // Highlight selected piece
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            const piece = cell.querySelector('.piece');
            if (piece) {
                piece.classList.add('selected');
            }
            
            // Calculate valid moves
            gameState.validMoves = calculateValidMoves(row, col);
            
            // Highlight valid moves
            highlightValidMoves();
        }

        // Calculate valid moves for a piece
        function calculateValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];
            
            const moves = [];
            const player = piece.player;
            const isKing = piece.isKing;
            const directions = [];
            
            // Determine movement directions based on player and king status
            if (player === 1 || isKing) {
                directions.push({ row: -1, col: -1 }); // Up-left
                directions.push({ row: -1, col: 1 });  // Up-right
            }
            if (player === 2 || isKing) {
                directions.push({ row: 1, col: -1 });  // Down-left
                directions.push({ row: 1, col: 1 });   // Down-right
            }
            
            // Check for capture moves first (mandatory captures)
            let captureMoves = [];
            
            for (const dir of directions) {
                const jumpRow = row + dir.row * 2;
                const jumpCol = col + dir.col * 2;
                const midRow = row + dir.row;
                const midCol = col + dir.col;
                
                // Check if jump is within board bounds
                if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8) {
                    const midPiece = gameState.board[midRow][midCol];
                    const targetCell = gameState.board[jumpRow][jumpCol];
                    
                    // Check if there's an opponent piece to jump over and target cell is empty
                    if (midPiece && midPiece.player !== player && !targetCell) {
                        captureMoves.push({
                            row: jumpRow,
                            col: jumpCol,
                            isCapture: true,
                            capturedPiece: { row: midRow, col: midCol }
                        });
                    }
                }
            }
            
            // If there are capture moves, only return those (captures are mandatory)
            if (captureMoves.length > 0) {
                return captureMoves;
            }
            
            // If no captures, check for regular moves
            for (const dir of directions) {
                const newRow = row + dir.row;
                const newCol = col + dir.col;
                
                // Check if move is within board bounds
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    // Check if target cell is empty
                    if (!gameState.board[newRow][newCol]) {
                        moves.push({
                            row: newRow,
                            col: newCol,
                            isCapture: false
                        });
                    }
                }
            }
            
            return moves;
        }

        // Highlight valid moves on the board
        function highlightValidMoves() {
            gameState.validMoves.forEach(move => {
                const cell = document.querySelector(`.cell[data-row="${move.row}"][data-col="${move.col}"]`);
                if (cell) {
                    const highlight = document.createElement('div');
                    highlight.className = move.isCapture ? 'capture-move' : 'valid-move';
                    cell.appendChild(highlight);
                }
            });
        }

        // Clear selection and highlights
        function clearSelection() {
            // Clear selected piece
            if (gameState.selectedPiece) {
                const prevCell = document.querySelector(`.cell[data-row="${gameState.selectedPiece.row}"][data-col="${gameState.selectedPiece.col}"]`);
                if (prevCell) {
                    const prevPiece = prevCell.querySelector('.piece');
                    if (prevPiece) {
                        prevPiece.classList.remove('selected');
                    }
                }
                gameState.selectedPiece = null;
            }
            
            // Clear valid move highlights
            document.querySelectorAll('.valid-move, .capture-move').forEach(el => el.remove());
            gameState.validMoves = [];
        }

        // Check if a cell is a valid move target
        function isValidMoveTarget(row, col) {
            return gameState.validMoves.some(move => move.row === row && move.col === col);
        }

        // Make a move
        function makeMove(row, col) {
            if (!gameState.selectedPiece) return;
            
            const move = gameState.validMoves.find(m => m.row === row && m.col === col);
            if (!move) return;
            
            const fromRow = gameState.selectedPiece.row;
            const fromCol = gameState.selectedPiece.col;
            const piece = gameState.board[fromRow][fromCol];
            
            // Save current state for undo
            gameState.moveHistory.push({
                board: JSON.parse(JSON.stringify(gameState.board)),
                currentPlayer: gameState.currentPlayer,
                player1Pieces: gameState.player1Pieces,
                player2Pieces: gameState.player2Pieces,
                player1Kings: gameState.player1Kings,
                player2Kings: gameState.player2Kings
            });
            
            // Update board state
            gameState.board[row][col] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            // Handle capture
            if (move.isCapture && move.capturedPiece) {
                gameState.board[move.capturedPiece.row][move.capturedPiece.col] = null;
                
                // Update piece counts
                if (gameState.currentPlayer === 1) {
                    gameState.player2Pieces--;
                } else {
                    gameState.player1Pieces--;
                }
            }
            
            // Check for king promotion
            if (!piece.isKing) {
                if ((piece.player === 1 && row === 0) || (piece.player === 2 && row === 7)) {
                    piece.isKing = true;
                    
                    // Update king counts
                    if (piece.player === 1) {
                        gameState.player1Kings++;
                    } else {
                        gameState.player2Kings++;
                    }
                }
            }
            
            // Update UI
            updateBoardUI();
            clearSelection();
            
            // Add move to history
            const moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + col)}${8 - row}`;
            if (move.isCapture) {
                addMoveToHistory(`Player ${gameState.currentPlayer}: ${moveNotation} (Capture)`);
            } else {
                addMoveToHistory(`Player ${gameState.currentPlayer}: ${moveNotation}`);
            }
            
            // Check for win
            if (checkWin()) {
                gameState.gameActive = false;
                updateGameStatus(`Player ${gameState.currentPlayer} wins!`);
                return;
            }
            
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            updatePlayerInfo();
            
            // Update game status
            updateGameStatus(`Player ${gameState.currentPlayer}'s turn (${gameState.currentPlayer === 1 ? 'Red' : 'Blue'})`);
            
            // If playing against computer and it's computer's turn
            if (gameState.gameMode === 'computer' && gameState.currentPlayer === 2 && gameState.gameActive) {
                setTimeout(makeComputerMove, 800);
            }
        }

        // Update the board UI
        function updateBoardUI() {
            // Clear the board
            document.querySelectorAll('.cell').forEach(cell => {
                const piece = cell.querySelector('.piece');
                if (piece) piece.remove();
            });
            
            // Redraw pieces
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        const pieceElement = createPieceElement(piece.player, piece.isKing);
                        cell.appendChild(pieceElement);
                    }
                }
            }
            
            updatePlayerInfo();
        }

        // Update player info display
        function updatePlayerInfo() {
            // Update active player highlight
            if (gameState.currentPlayer === 1) {
                player1Info.classList.add('active');
                player2Info.classList.remove('active');
            } else {
                player1Info.classList.remove('active');
                player2Info.classList.add('active');
            }
            
            // Update piece counts in player info
            const player1PiecesEl = player1Info.querySelector('.player-pieces');
            const player2PiecesEl = player2Info.querySelector('.player-pieces');
            
            player1PiecesEl.innerHTML = '';
            player2PiecesEl.innerHTML = '';
            
            // Add indicator for regular pieces
            for (let i = 0; i < gameState.player1Pieces - gameState.player1Kings; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'piece-indicator player1-indicator';
                player1PiecesEl.appendChild(indicator);
            }
            
            // Add indicator for king pieces
            for (let i = 0; i < gameState.player1Kings; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'piece-indicator king-indicator';
                player1PiecesEl.appendChild(indicator);
            }
            
            // Add indicator for regular pieces
            for (let i = 0; i < gameState.player2Pieces - gameState.player2Kings; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'piece-indicator player2-indicator';
                player2PiecesEl.appendChild(indicator);
            }
            
            // Add indicator for king pieces
            for (let i = 0; i < gameState.player2Kings; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'piece-indicator king-indicator';
                player2PiecesEl.appendChild(indicator);
            }
        }

        // Update game status display
        function updateGameStatus(message) {
            gameStatus.textContent = message;
            
            // Check if it's a win message
            if (message.includes('wins')) {
                gameStatus.classList.add('winner');
            } else {
                gameStatus.classList.remove('winner');
            }
        }

        // Add move to history
        function addMoveToHistory(moveText) {
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.textContent = moveText;
            moveList.appendChild(moveItem);
            
            // Scroll to bottom
            moveList.scrollTop = moveList.scrollHeight;
        }

        // Check for win condition
        function checkWin() {
            // Check if a player has no pieces left
            if (gameState.player1Pieces === 0) {
                return true; // Player 2 wins
            }
            if (gameState.player2Pieces === 0) {
                return true; // Player 1 wins
            }
            
            // Check if current player has any valid moves
            const currentPlayer = gameState.currentPlayer;
            let hasValidMoves = false;
            
            for (let row = 0; row < 8 && !hasValidMoves; row++) {
                for (let col = 0; col < 8 && !hasValidMoves; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.player === currentPlayer) {
                        const moves = calculateValidMoves(row, col);
                        if (moves.length > 0) {
                            hasValidMoves = true;
                        }
                    }
                }
            }
            
            // If current player has no valid moves, opponent wins
            if (!hasValidMoves) {
                return true;
            }
            
            return false;
        }

        // Make a computer move
        function makeComputerMove() {
            if (!gameState.gameActive || gameState.currentPlayer !== 2) return;
            
            // Find all pieces that can move
            const movablePieces = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.player === 2) {
                        const moves = calculateValidMoves(row, col);
                        if (moves.length > 0) {
                            movablePieces.push({ row, col, moves });
                        }
                    }
                }
            }
            
            if (movablePieces.length === 0) return;
            
            // Select a random piece to move (with preference for captures)
            let selectedPiece;
            let selectedMove;
            
            // First check for capture moves
            const piecesWithCaptures = movablePieces.filter(p => p.moves.some(m => m.isCapture));
            
            if (piecesWithCaptures.length > 0) {
                // Select random piece with capture
                selectedPiece = piecesWithCaptures[Math.floor(Math.random() * piecesWithCaptures.length)];
                // Select random capture move
                const captureMoves = selectedPiece.moves.filter(m => m.isCapture);
                selectedMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
            } else {
                // Select random piece
                selectedPiece = movablePieces[Math.floor(Math.random() * movablePieces.length)];
                // Select random move
                selectedMove = selectedPiece.moves[Math.floor(Math.random() * selectedPiece.moves.length)];
            }
            
            // Select the piece and make the move
            selectPiece(selectedPiece.row, selectedPiece.col);
            setTimeout(() => {
                makeMove(selectedMove.row, selectedMove.col);
            }, 500);
        }

        // Restart the game
        function restartGame() {
            if (gameState.gameMode) {
                startGame(gameState.gameMode);
            } else {
                initBoard();
                gameState.gameActive = false;
                updateGameStatus("Select a game mode to start playing!");
            }
        }

        // Undo last move
        function undoMove() {
            if (gameState.moveHistory.length === 0 || !gameState.gameActive) return;
            
            const lastState = gameState.moveHistory.pop();
            
            // Restore game state
            gameState.board = lastState.board;
            gameState.currentPlayer = lastState.currentPlayer;
            gameState.player1Pieces = lastState.player1Pieces;
            gameState.player2Pieces = lastState.player2Pieces;
            gameState.player1Kings = lastState.player1Kings;
            gameState.player2Kings = lastState.player2Kings;
            
            // Update UI
            updateBoardUI();
            clearSelection();
            updatePlayerInfo();
            updateGameStatus(`Player ${gameState.currentPlayer}'s turn (${gameState.currentPlayer === 1 ? 'Red' : 'Blue'})`);
            
            // Remove last move from history
            if (moveList.lastChild) {
                moveList.removeChild(moveList.lastChild);
            }
        }

        // Show a hint
        function showHint() {
            if (!gameState.gameActive || gameState.currentPlayer !== 1) return;
            
            // Find a piece with valid moves
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.player === 1) {
                        const moves = calculateValidMoves(row, col);
                        if (moves.length > 0) {
                            // Highlight the piece
                            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                            const pieceEl = cell.querySelector('.piece');
                            if (pieceEl) {
                                pieceEl.style.boxShadow = '0 0 0 3px #00ff00, 0 0 15px #00ff00';
                                setTimeout(() => {
                                    pieceEl.style.boxShadow = '';
                                }, 2000);
                            }
                            
                            updateGameStatus("Hint: Try moving the highlighted piece");
                            return;
                        }
                    }
                }
            }
        }

        // Start a new game
        function startGame(mode) {
            gameState.gameMode = mode;
            gameState.gameActive = true;
            gameState.currentPlayer = 1;
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.moveHistory = [];
            gameState.player1Pieces = 12;
            gameState.player2Pieces = 12;
            gameState.player1Kings = 0;
            gameState.player2Kings = 0;
            
            initBoard();
            
            if (mode === 'computer') {
                updateGameStatus("Playing against computer. Player 1's turn (Red)");
            } else {
                updateGameStatus("Playing with a friend. Player 1's turn (Red)");
            }
            
            // Hide tutorial if visible
            tutorialContainer.classList.remove('active');
        }

        // Event listeners
        tutorialBtn.addEventListener('click', () => {
            tutorialContainer.classList.add('active');
            gameState.gameActive = false;
            updateGameStatus("Viewing tutorial - select a game mode to play");
        });

        closeTutorialBtn.addEventListener('click', () => {
            tutorialContainer.classList.remove('active');
            if (gameState.gameMode) {
                gameState.gameActive = true;
                updateGameStatus(`Player ${gameState.currentPlayer}'s turn (${gameState.currentPlayer === 1 ? 'Red' : 'Blue'})`);
            }
        });

        playComputerBtn.addEventListener('click', () => {
            startGame('computer');
        });

        playFriendBtn.addEventListener('click', () => {
            startGame('friend');
        });

        restartBtn.addEventListener('click', restartGame);

        undoBtn.addEventListener('click', undoMove);

        hintBtn.addEventListener('click', showHint);

        backToMenuBtn.addEventListener('click', () => {
            gameState.gameMode = null;
            gameState.gameActive = false;
            initBoard();
            updateGameStatus("Select a game mode to start playing!");
            moveList.innerHTML = '<div class="move-item">Game started</div>';
        });

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            initBoard();
            initExampleBoards();
        });
    </script>
</body>
</html>
